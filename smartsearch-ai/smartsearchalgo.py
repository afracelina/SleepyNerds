# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1X4XLVCFrlBCaVE0afb-5s_9maFNiUNTA
"""

import pandas as pd
from datetime import datetime

# Données sur les hébergements
data = {
    "id": [1, 2, 3, 4, 5],
    "name": ["Hôtel A", "Auberge B", "Complexe C", "Hôtel D", "Auberge E"],
    "type": ["hotel", "auberge", "complex", "hotel", "auberge"],
    "price_per_night": [100, 80, 150, 200, 50],
    "average_review": [4.5, 4.0, 4.8, 4.2, 3.8],
    "available_from": [datetime(2024, 12, 20), datetime(2024, 12, 22), datetime(2024, 12, 20), datetime(2024, 12, 25), datetime(2024, 12, 20)],
    "available_until": [datetime(2024, 12, 30), datetime(2024, 12, 28), datetime(2024, 12, 31), datetime(2024, 12, 30), datetime(2024, 12, 25)],
    "options": [["wifi", "piscine"], ["wifi"], ["piscine", "spa"], ["wifi", "gym"], ["wifi", "barbecue"]]
}

# Créer le DataFrame
accommodations_df = pd.DataFrame(data)

# Liste des hébergements correspondants (ID, distance, disponibilité)
matching_accommodations = [
    (1, 1.2, True),  # ID = 1, distance = 1.2 km, disponible
    (2, 0.5, True),  # ID = 2, distance = 0.5 km, disponible
    (3, 2.0, True),  # ID = 3, distance = 2.0 km, disponible
    (4, 1.0, True),  # ID = 4, distance = 1.0 km, disponible
    (5, 3.5, True),  # ID = 5, distance = 3.5 km, disponible
]

# Paramètres du scénario
budget = 100
accommodation_type = "hotel"
check_in_date = datetime(2024, 12, 22)
check_out_date = datetime(2024, 12, 28)
transport_preference = "bus"  # Non utilisé dans cette version
options = ["wifi", "piscine"]
k = 3  # Nombre de résultats souhaités

# Fonction de classification renommée en ranked_request
def ranked_request(
    matching_accommodations, accommodations_df, k, budget, accommodation_type, check_in_date,
    check_out_date, transport_preference, options, distance_weight=0.25, budget_weight=0.3,
    review_weight=0.25, options_weight=0.2
):
    scores = []

    for accommodation in matching_accommodations:
        accommodation_id, spatial_distance, available_time = accommodation
        accommodation_row = accommodations_df.loc[accommodations_df['id'] == accommodation_id].iloc[0]

        # Vérifier le type d'hébergement
        if accommodation_row['type'] != accommodation_type:
            continue

        # Calcul du score de distance
        distance_score = (1 / (1 + spatial_distance)) * distance_weight

        # Calcul du score de budget
        budget_score = max(0, 1 - abs(accommodation_row['price_per_night'] - budget) / budget) * budget_weight

        # Calcul du score d'avis
        review_score = (accommodation_row['average_review'] / 5) * review_weight

        # Vérifier la disponibilité des chambres
        availability_score = 0
        if check_in_date >= accommodation_row['available_from'] and check_out_date <= accommodation_row['available_until']:
            availability_score = 1

        # Calcul des options spécifiques
        options_score = sum(
            1 for option in options if option in accommodation_row['options']
        ) / len(options) * options_weight if options else 0

        # Calcul du score global
        total_score = distance_score + budget_score + review_score + availability_score + options_score

        scores.append((accommodation_id, total_score))

    # Trier les scores par ordre décroissant
    sorted_scores = sorted(scores, key=lambda x: x[1], reverse=True)

    # Récupérer les k meilleurs hébergements
    k_best_accommodations = [item[0] for item in sorted_scores[:k]]

    classified_data = accommodations_df[accommodations_df['id'].isin(k_best_accommodations)]

    return classified_data

# Appeler la fonction
classified_data = ranked_request(
    matching_accommodations,
    accommodations_df,
    k,
    budget,
    accommodation_type,
    check_in_date,
    check_out_date,
    transport_preference,
    options
)

# Afficher les résultats
print("Scénario - Meilleurs hôtels :")
for index, row in classified_data.iterrows():
    print(f"Nom: {row['name']}, Prix/Nuit: {row['price_per_night']}, Avis moyen: {row['average_review']}")